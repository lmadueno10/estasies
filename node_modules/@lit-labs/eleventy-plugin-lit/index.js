"use strict";
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const worker_threads_1 = require("worker_threads");
function configureWorker(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
eleventyConfig, resolvedComponentModules) {
    let worker;
    const requestIdResolveMap = new Map();
    let requestId = 0;
    eleventyConfig.on('eleventy.before', async () => {
        worker = new worker_threads_1.Worker(path.resolve(__dirname, './worker/worker.js'));
        worker.on('error', (err) => {
            console.error('Unexpected error while rendering lit component in worker thread', err);
            throw err;
        });
        let requestResolve;
        const requestPromise = new Promise((resolve) => {
            requestResolve = resolve;
        });
        worker.on('message', (message) => {
            switch (message.type) {
                case 'initialize-response': {
                    requestResolve();
                    break;
                }
                case 'render-response': {
                    const { id, rendered } = message;
                    const resolve = requestIdResolveMap.get(id);
                    if (resolve === undefined) {
                        throw new Error('@lit-labs/eleventy-plugin-lit received invalid render-response message');
                    }
                    resolve(rendered);
                    requestIdResolveMap.delete(id);
                    break;
                }
            }
        });
        const message = {
            type: 'initialize-request',
            imports: resolvedComponentModules,
        };
        worker.postMessage(message);
        await requestPromise;
    });
    eleventyConfig.on('eleventy.after', async () => {
        await worker.terminate();
    });
    eleventyConfig.addTransform('render-lit', async (content, outputPath) => {
        if (outputPath && !outputPath.endsWith('.html')) {
            return content;
        }
        const renderedContent = await new Promise((resolve) => {
            requestIdResolveMap.set(requestId, resolve);
            const message = {
                type: 'render-request',
                id: requestId++,
                content,
            };
            worker.postMessage(message);
        });
        const outerMarkersTrimmed = trimOuterMarkers(renderedContent);
        return outerMarkersTrimmed;
    });
}
function configureVm(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
eleventyConfig, resolvedComponentModules) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    if (require('vm').Module === undefined) {
        // Show a more friendly error message if the --experimental-vm-modules
        // flag is missing.
        const red = '\u001b[31m';
        const yellow = '\u001b[33m';
        const reset = '\u001b[0m';
        console.error(`${yellow}
┌─────────────────────${red} ERROR ${yellow}─────────────────────┐
│${reset}                                                 ${yellow}│
│${reset} @lit-labs/eleventy-plugin-lit requires Node     ${yellow}│
│${reset} version 12.16.0 or higher, and that eleventy is ${yellow}│
│${reset} launched with a special environment variable    ${yellow}│
│${reset} to enable an experimental feature:              ${yellow}│
│${reset}                                                 ${yellow}│
│${reset} NODE_OPTIONS=--experimental-vm-modules eleventy ${yellow}│
│${reset}                                                 ${yellow}│
└─────────────────────────────────────────────────┘
${reset}`);
        throw new Error('@lit-labs/eleventy-plugin-lit requires that eleventy be launched ' +
            'with NODE_OPTIONS=--experimental-vm-modules');
    }
    const renderModulePath = path.join(process.cwd(), 'arbitrary.js');
    let contextifiedRender;
    let contextifiedUnsafeHTML;
    // Create a fresh context before each build, so that our module cache resets
    // on every --watch mode build.
    // TODO(aomarks) For better performance, we could re-use contexts between
    // build, but selectively invalidate its cache so that only the user's
    // modules are reloaded.
    eleventyConfig.on('eleventy.before', async () => {
        // Note this file must be CommonJS for compatibility with Eleventy, but
        // TypeScript's CommonJS output mode will also convert dynamic import()
        // calls to require() calls. That would be bad, because we need
        // to import ES modules from @lit-labs/ssr, which requires preserved
        // import() calls.
        // So we use eval(`import()`) instead
        //
        // See https://github.com/microsoft/TypeScript/issues/43329 for details
        const { getWindow } = (await eval(`import('@lit-labs/ssr/lib/dom-shim.js')`));
        const { ModuleLoader } = (await eval(`import('@lit-labs/ssr/lib/module-loader.js')`));
        const window = getWindow({ includeJSBuiltIns: true });
        const loader = new ModuleLoader({ global: window });
        // TODO(aomarks) Replace with concurrent Promise.all version once
        // https://github.com/lit/lit/issues/2549 has been addressed.
        for (const module of resolvedComponentModules) {
            await loader.importModule(module, renderModulePath);
        }
        contextifiedRender = (await loader.importModule('@lit-labs/ssr/lib/render-lit-html.js', renderModulePath)).module.namespace.render;
        // TOOD(aomarks) We could also directly synthesize an html TemplateResult
        // instead of doing so via the the unsafeHTML directive. The directive is
        // performing some extra validation that doesn't really apply to us.
        contextifiedUnsafeHTML = (await loader.importModule('lit/directives/unsafe-html.js', renderModulePath)).module.namespace.unsafeHTML;
    });
    eleventyConfig.addTransform('render-lit', async (content, outputPath) => {
        if (outputPath && !outputPath.endsWith('.html')) {
            return content;
        }
        // TODO(aomarks) Maybe we should provide a `renderUnsafeHtml` function
        // directly from SSR which does this.
        const iterator = contextifiedRender(contextifiedUnsafeHTML(content));
        const concatenated = iterableToString(iterator);
        const outerMarkersTrimmed = trimOuterMarkers(concatenated);
        return outerMarkersTrimmed;
    });
}
module.exports = {
    configFunction: function (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    eleventyConfig, { componentModules, mode = 'worker' } = {}) {
        if (componentModules === undefined || componentModules.length === 0) {
            // If there are no component modules, we could never have anything to
            // render.
            return;
        }
        const resolvedComponentModules = componentModules.map((module) => path.resolve(process.cwd(), module));
        switch (mode) {
            case 'worker': {
                configureWorker(eleventyConfig, resolvedComponentModules);
                break;
            }
            case 'vm': {
                configureVm(eleventyConfig, resolvedComponentModules);
                break;
            }
            default: {
                throw new Error('Invalid mode provided for @lit-labs/eleventy-plugin-lit');
            }
        }
    },
};
// Lit SSR includes comment markers to track the outer template from
// the template we've generated here, but it's not possible for this
// outer template to be hydrated, so they serve no purpose.
// TODO(aomarks) Maybe we should provide an option to SSR option to skip
// outer markers (though note there are 2 layers of markers due to the
// use of the unsafeHTML directive).
function trimOuterMarkers(renderedContent) {
    return renderedContent
        .replace(/^((<!--[^<>]*-->)|(<\?>)|\s)+/, '')
        .replace(/((<!--[^<>]*-->)|(<\?>)|\s)+$/, '');
}
// Assuming this is faster than Array.from(iter).join();
// TODO: perf test
const iterableToString = (iterable) => {
    let s = '';
    for (const i of iterable) {
        s += i;
    }
    return s;
};
//# sourceMappingURL=index.js.map